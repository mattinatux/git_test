INTRO: SELF TEST AS YOU GO
    How do you declare a variable?
    What are three different ways to declare a variable?
    Which one should you use when?
    What are the rules for naming variables?
    What are operators, operands, and operations?
    What is concatenation and what happens when you add numbers and strings together?
    What are the different types of operators in JavaScript?
    What is the difference between == and ===?
    What are operator precedence values?
    What are the increment/decrement operators?
    What is the difference between prefixing and post-fixing them?
    What are assignment operators?
    What is the “Unary +” Operator?

Good (clean) Code Topics:
Comments: // at beginning of line
Identation: doesn't matter, just recommended
Semicolons: mostly optional b/c compiler catches it, but YOU SHOULD STILL DO IT
Line length: doesn't matter, try to keep <= 80 characters.
    if going multiple lines, break at operator or comma and indent
Naming things: descriptive names are good.


Writing Code:
console.log("Hello, World!")
    - You can view this in the developer tooler > console. Handy for... debugging?

variables
    - Three ways to delcare:
        1. var: old way, only weay before let/const
        2. let: most common, new way
        
        3. const: an unchanging variable, cannot be reassigned
            - BUT, if an array, you can change, append, etc. a const var just fine

        ** if files contains: "use strict";  then variables MUST be declared before use
        ** by default, use strict is not used. as such, you can declare a variable by assignment only (like PowerShell)
            num = 5; is valid, without doing a let, unless "use strict" is on.
            in any case, ALWAYS declare with JavaScript.
    
    - Assign a value with the assignment operator (=)

    - Access by calling by name

        E.g. (verbose):
            let message;
            message = 'Hello!';
            alert(message);
        
        E.g. (casual):
            let message = 'Hello!';
            alert(message);
    
    - Declare multiple variables in one line is possible, but harder to read:
        let user = 'John', age = 25, message = 'Hello!'
    - Multiline declaration also avaialble, a mix of the basic or the one liner option:
        let user = 'John',
            age = 25,
            message = 'Hello!';

    - DON'T DECLARE TWICE! Compile error...

    - Variable naming limitations:
        1. Variable may contain only letters, digits, or the symbols $ or _
        2. The first character must not be a digit
    
    Casing
        - Camel case preferred
        - Variables are case sensitive
        - If declaring an already-known constant (that is, doesn't require run time calcluations to declare),
          it is common to do it in all caps. E.g., const COLOR_ORANGE = "#FF7F00";
    
numbers
    - can write with our without decimal
    - can write using scientific notation
    - *** ALWAYS 64-bit floating point *** (also known as double data type)
        Other languages: int, short, long, floating-point, etc.
        JavaScript: stores in 64 bits.
            the number (the fraction) stored in bits 0 - 51
            the exponent in bits 52 - 62
            the sign in bit 63
    - Integers (#s w/o period or scientific notation accurate up to 15 digits)
        let x = 999999999999999;   // x will be 999999999999999
        let y = 9999999999999999;  // y will be 10000000000000000
    - Decimals max at 17
    - Floating point decimal math isn't always right...
        let x = 0.2 + 0.1; results in 0.30000000000000004
            ** fix it by multiplying and dividing (to get it out and back into decimal)
            ** let x = (0.2 * 10 + 0.1 * 10)  / 10; results in 0.3
    - For all operators EXCEPT (+), JavaScript will attempt to convert any numerical strings ("10", e.g.) to a number and math it.
        Convert a numeric STRING to a NUMBER with the function... Number()
        EX: let myNumber = '24';
            Number(myNumber) + 3;
    
    - NaN - a JavaScript reserved word indicating a number is not a legal number
        - let x = 100 / "Apple"; // x will be NaN
        - Can check is isNaN();
            isNaN(someValue);
        - NaN is considered a number

    - Infinity (or, -Infinity) represents a number outside of the largest calcuable number
        Ex 1: Executes forever
            let myNum = 2;
            while (myNum != Infinity) {
                myNum = myNum + myNum;
            }
        Ex 2: Divide by 0 and break the universe
            let x = 2 / 0;
            // x will be Infinity
            let y = -2 / 0;
            // y will be -Infinity
        - Infinity is considered a number
                typeof Infinity; //returns number

    Hexadecimal is an option
        - JavaScript interprets numberic constants as Hexadecimal if they are preceded by 0x.
            let x = 0xFF; // x will be 255
        
    ** NEVER write a number with a leading 0. Some versions of JavaScript interprets as octal if written this way.

    Bases
         2 - Binary - uses 0-1 in each column
         8 - Octal - uses 0-7 in each column
        10 - Decimal (default) - uses 0-9 in each column
        16 - Hexadecimal - uses 0-9 and then a-f in each column

        Output from base 2 to base 36 by using toString();
            Ex: let myNum = 32;
                    myNum.toString(10); //returns 32
                    myNum.toString(2); //returns 100000

Round numbers by using a method! The method is... toFixed()
    EX: 1.723.toFixed(2) gets ya 1.72

Numbers can be Objects, BUT DON'T DO THIS BECAUSE IT COMPLICATES CODE AND SLOWS DOWN EXECUTION SPEED
    Use keyword "new" to define number as an object.

    EX: let y = new Number(123);
        typeof y; //returns object, not number

    Don't use because:
        # == new # // true
        # === new # // false, b/c not same type
        new # == new # // false because objects can't be compared

Operators
    + operator
        - Used to both concantenate and to add
        - "10" + 20 = 1020
        - 10 + 20 = 30
        - 10 + "20" = 1020
        - Common mistake:
            let x = 10;
            let y = 20;
            let z = "the result is: " + x + y;
            Expect: 30
            Outputs: the result is: 1020
        - Leads to this common mistake:
            let x = 10;
            let y = 20;
            let z = "30";
            let result = x + y + z;
            Expect: 102030 (because a string is involved, right?)
            Outputs: 3030
            *** Take away: JavaScript interpreter goes left to right. Once a string is seen, it concatinates. Until a string is seen, it adds.

    == operator
        - expects equality in value
        - "equal"

    === operator
        - expects equality in both type and value
        - "strict equal"

    - operator
        - subtraction

    * operator
        - multiplication

    ** operator
        - exponention
            EX: 5 ** 2 results in 25 (5 squared)
        - same result as using Math.pow(x,y)
            EX: Math.pow(5,2); //result is 25

    / operator
        - division

    % operator
        - modulus (remainder)
            EX: 5 / 2 is 2 with a remainder of 1
                type as 5 % 2, and the result will be "1"

    ++ operator
        - increment

    -- operator
        - decrement
    
    Operator precedence:

        Value	Operator	Description	        Example
        21  	( )	        Expression grouping	(3 + 4)

        20	    .	        Member	            person.name
        20	    []	        Member	            person["name"]
        20	    ()	        Function call	    myFunction()
        20	    new	        Create	            new Date() (this one is useful; can instantiate a user-defined object or a built in object type with a contructor function, e.g., new date() works but date() alone doesn't)
        18	    ++	        Postfix Increment	i++
        18	    --	        Postfix Decrement	i--
        17	    ++      	Prefix Increment	++i
        17	    --      	Prefix Decrement	--i
        17	    !       	Logical not     	!(x==y) (this results in a t/f evaluation; saying "alert('hi');" returns "hi". saying "alert(!'hi');" returns "false". !!'hi' returns true.)
        17  	typeof  	Type            	typeof x

        16  	**      	Exponentiation  	10 ** 2
        15  	*       	Multiplication  	10 * 5
        15	    /       	Division        	10 / 5
        15	    %       	Division Remainder	10 % 5
        14  	+       	Addition        	10 + 5
        14	    -       	Subtraction	        10 - 5

        13  	<<	        Shift left      	x << 2
        13	    >>	        Shift right	        x >> 2
        13	    >>>     	Shift right     	x >>> 2

        12  	<   	    Less than       	x < y 
        12	    <=	        Less than or equal	x <= y
        12	    >	        Greater than	    x > y
        12	    >=	        Greater than equal	x >= y

        12	    in	        Property in Object	"PI" in Math
        12	    instanceof	Instance of Object	instanceof Array
                    
        11  	==      	Equal           	x == y
        11  	===     	Strict equal    	x === y (typically results in fewer errors, perfer this over not strict)
        11  	!=      	Unequal         	x != y
        11  	!==     	Strict unequal  	x !== y (typically results in fewer errors, prefer this over not strict)
                    
        10	    &	        Bitwise AND     	x & y
        9	    ^	        Bitwise XOR	        x ^ y
        8	    |	        Bitwise OR	        x | y
        7	    &&	        Logical AND	        x && y (people improperly use this and || by doing things like "(X>0) && alert(something);" because JS evaluates the first statement, then moves on and will execute the next one (pending truthiness of first statement of course since it COULD break with a false if needed). don't do that.)
        6	    ||	        Logical OR	        x || y (in conditional log, this is a "v". it is just an OR statement. a chain of these will return the first TRUE value it runs into, else returns false at the end. this allos stuff like short-circuit evals e.g., true || alert("not printed"; or perhaps false || alert("printed");)
        5	    ??      	Nullish Coalescing	x ?? y
        4	    ? :         Condition          	? "Yes" : "No" (usage-- condition ? value/code if true : value/code if false; used to assign a variable depending on a condition, shorter then a bunch of if statements and variable setting; e.g.: let (age > 18) ? true : false; [in this example though, age > 18 would actually not need the ?, because it is evaluated properly as t/f if age = a number])
                    
        3	    +=	        Assignment	        x += y (x = 10; y = 5; x += y; // x returns 15)
        3   	/=	        Assignment      	x /= y
        3   	-=	        Assignment      	x -= y
        3	    *=	        Assignment	        x *= y (x = 10; y = 5; x *= y; //x returns 50 - it basically is a way to manipulate the variable with math done on itself)
        3	    %=	        Assignment	        x %= y
        3	    <<=	        Assignment	        x <<= y
        3	    >>=	        Assignment	        x >>= y
        3	    >>>=	    Assignment	        x >>>= y
        3	    &=	        Assignment	        x &= y
        3	    ^=	        Assignment	        x ^= y
        3	    |=      	Assignment	        x |= y
                    
        2	    yield	    Pause Function	    yield x
        1	    ,       	Comma	            5 , 6

        Expressions in parentheses are fully computed before the value is used in the rest of the expression.

METHOD: .addEventListener(when,dowhat)
        EX: 
            <button>Start machine</button>
            <p>Thee machine is currently stopped.</p>
            
            const btn = document.querySelector('button'); //this is where we attach to the HTML element I expects
            const txt = document.querySelector('p'); //like the last one, attaching to the p element

            btn.addEventListener('click', updateBtn);

            function updateBtn() {
                if (btn.textContent === 'Start machine') {
                    btn.textContent = 'Stop machine'; //because the button was clicked, make the button the opposite of what it was
                    txt.textContent = 'Now the machine is running!'; //and make the text area confirm that it was clicked
                } else {
                    btn.textContent = 'Start machine';
                    txt.textContent = 'Its stopped';
                }
            }

JavaScript Data types
    There are 8!

    Number - covered above

    BigInt - handles big numbers like ones for crypto, etc.
        - specified by adding an 'n' at the end of the number
        EX: const myBigNum = 1234567890987654321123456789n;
    
    String - you know what a string is
        - three ways:
            double quote "hi";
            single quotes: 'hi';
            backticks (known as template literals):
                `hi, i can embed from another ${str}`;
                `i can also embed expressions like this: ${1+2}`;
                easier this way than concantnating: "Hi" + name + "." vs `Hi ${name}.`
        - can mix like this: "It's me!";
        - or like this: 'Hey "bob", if that is your real name";
        - but you might need an escape character like this: 'Hey "bob", if that\'s your real name";
        
        - List of string methods: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String
            .length - returns length (like PowerShell did, too)
            .slice(start,end) - returns the text between those characters. if negative, starts at end of line.
                - if you only include start, method will slice out rest of string
                - it RETURNS the slice you are taking
            .substring(start,end) - like slice, but can't handle negatives
            .substr(start,length) - like slice, but specifies length of extracted part (not end character of it)
            .replace(what,withwhat) - like PowerShell
                - by default, replaces only the first match
                    - to replace all, use a regular expression with a /g flag
                      EX: text.replace(/what/g, "withwhat")
                - by default, case sensitive
                    - to make case insensitive, use a regular expression with an /i flag
                      EX: text.replace(/WhAT/i, "withwhat")
            .toUpperCase()
            .toLowerCase()
            .concat(text1,text2) - concantinates as a method, can be used instead of the plus operator
                EX: these are the same
                    "hello" + " " + "world!"
                    "hello".concat(" ", "World!")
            .trim() - removes whitespace from both sides of a string
            .padStart(totalChars,withwhat) - will put as many "withwhat"s to reach total string characters as needed
            .padEnd(totalChars,withwhat)
            .charAt(position) - returns the character at the position specified
            .charCodeAt(position) - returns the unicode of the character
            [] - property access on strings works
                EX: text[5] returns the sixth character from the text string
                Property access can be unpredictable with strings though...
                    - BEWARE: it makes strings look like JavaScript arrays, but they aren'T
                    - BEWARE: if no character found, you get undefined (not an empty string)
                    - BEWARE: you can't set these. they are READ ONLY.
            .split(",") - splits on commas, like for a CSV import or somethin
                - Results in the string converting to an array!
                - If you use split(""), it will put each letter in separately (you can .join("") them back later if you need to)
    
    Boolean (logical type) - true or false

    null - represents nothing, empty, or value unknown in JavaScript (as opposed to a non-existing object or a null pointer)

    undefined - represents value not assigned, like if a variable is declared but not assigned, then it is undefined

    Object - special, stores collections of data

    Symbol - creates unique identifiers for objects

Escape character: \

New line character: \n
    - Only needed with single or double quotes
    - Not needed with template literals (backticks) because they respect line breaks in the source code.
        This would actually show a linebreak:
            output = `I like ${foodName}.
            It is my favorite food.`


Conditionals
    Normal stuff mostly
    Some things to keep in mind:
        - a=0, b="0"
            a is not a boolean, but b is because it is a string
            but JavaScript converts the string to a number on the conditional, so a==b
        - use strict equality (===)
            ex: JavaScript cannot differentiate 0 from false:
                alert(0 == false); // returns true
            ex: same with an empty string: alert ('' == false); // returns true
            - but with a strict equality, the types are noted as different, so it works out as expected

    null === undefined: false
    null == undefined: true
        - when converted to numbers, null becomes 0 and undefined becomes NaN

    equality checks work different than comparisons
        - comparisons convert null to a number (0)
            - so null >= 0 is true AND null > 0 is false
        - equality check says without any conversions they must equal each Other
            - so null == 0 false
    
    comparisons of 'undefined' will ALWAYS be false because:
        - as a number, undefined becomes NaN and NaN always returns false when compared
    undefined ONLY equals null or undefined
    
    Upshots:
        - be really careful if doing anything but === with undefined/null
        - be really careful comparing a variable that COULD BE null/undefined; if a variable COULD have the values, check for them separately first and wrap it

If/Else/Switch
    if (condition) {
        // code block
    } else if {
        // code block
    } else {
        // code block
    }

    switch (expression) {
        case x:
            // code block
            break;
        case y:
            // code block
            break;
        default:
            // code block
    }

        Note: the "cases" are evaluated in order, so you include that break to get out if there is a match.
                also, you can do evaluations in the case. E.g., case grade >= 90: letterGrade = "A"; break;
        
        Note: you can "skip over" cases to "group" things. E.g., case 0: case 1: case 2: console.log("WINTER"); break;

        EX:
            switch (new Date().getDay()) {
            case 0:
                day = "Sunday";
                break;
            case 1:
                day = "Monday";
                break;
            case 2:
                day = "Tuesday";
                break;
            case 3:
                day = "Wednesday";
                break;
            case 4:
                day = "Thursday";
                break;
            case 5:
                day = "Friday";
                break;
            case  6:
                day = "Saturday";
            }

                Exercises from https://javascript.info/ifelse:
                    let answer = prompt("What's the day of the week?");
                    let dow2 = new Date().getDay();
                    switch (dow2) {
                        case 1:
                            dow2 = "Monday"
                            break;
                        case 2:
                            dow2 = "Tuesday"
                    }

                    if (dow2 == answer) {
                        alert('nice!');
                    } else {
                        alert('nope!');
                    }

                    let result;
                    if (1 + 2 < 4) {
                        result = 'Below';
                    } else {
                        result = 'Over';
                    }

                    changed these from if/else to one liners for practice, but try to not do this IRL!!
                        
                        let result = (1 + 2 < 4) ? "Below" : "Over";
                        
                        let login = 'director';
                        let message = (login == 'employee') ? 'Hello' : (login == 'director') ? 'Greetings, D' : 'who are you?'

JavaScript Developer Tools

    HTML v DOM
        - you request the HTML page
        - HTML page contains elements, scripts, etc. Browser parses that out into the tree of objects (or, nodes), which is called the DOM.
        - the DOM could be different than the HTML, e.g. in cases where a script changes content on the page.
        * The DOM is the /current/ page content as displayed to the user

    Debug JavaScript: Dev Tools > Sources Panel
        - Event Listener Breakpoints can be inserted for debugging:
            1. Event listener breakpoints section at bottom left of the dev tools (while in sources)
            2. Choose the JavaScript file you want to debug at top left
            2. Mouse > Click used as an example to pause between any click events
    
    Code editor - don't forget to SAVE if you want it to be active! :-)
    
    Breakpoints
        Line-of-code - can set them on the line by clicking the number in the code editor
            Can also add "debugger;" to code to get a pause. acts like a LoC breakpoint.
        Conditional line-of-code - right click on the line, set the condition. useful if you want to stop there IF something else is true (like a variable being set to something, e.g.)
            Can  manage these from the "breakpoints" pane
        DOM change - to pause on code that changes a DOM node or its children
            Do it from Elements tab > right click element > "break on . . ."
                Subtree modifications - triggered when child of selected node is removed or added, or contents are changed. NOT triggered on child node attribute changes or any changes to the selected node itself
                Attributes modifications - triggered when an attribute is added or removed on the currently-selected node, or when an attribute value changes
                Node removal - triggered when currently-selected node is removed
                SOOOOOO - you can monitor the children for content changes, additions, or removals, BUT NOT for attribute changes (as a whole). Attribute changes are node-monitoring-specific.
        XHR/Fetch - to pause code when a specific string is presented in an XHR's request unpredictable
            Useful for finding when a specific URL is being launched, e.g., can break on "org" being sent.
            Can do it from Sources > XHR Breakpoints pane > Add breakpoint
        Event Listener - from the event listener breakpoints pane
        Exceptions - from the sources tab, click "pause on exceptions" stop sign box
        Function - call debug(functionName)
            Make sure the function you want to debug is within scope, else will get a ReferenceError

    Step over - execute the code your passing over to get to the next pause, useful if the paused area isn't interesting
    Step into - when you get to the interesting function, step into it to dig deeper
    Step out - when you thought the function was interestig, but it really isn't and you want to continue on your quest

    Continue to Here - right click on a line of code you want to inestigate and choose "Continue to Here"
        results in all code being run up to that point, pausing at the start of the line chosen

    Force script execution - to blow past your breakpoints and resume full execution, long click on the Resume Script Execution button (looks like play/pause) and choose to force.

    Call Stack pane - when paused, view the call stack that got you to this point. 

TOP Fundamentals Part 3
    Functions
        Built ins, like .replace(), .join(), and .random()

        Functions vs Methods
            Functions: a reusable code block to do a things
            Methods: functions that are part of objects

        Anonymous functions
            Functions without a name. Typically used with event handlers.
                
                EX 1: this function would be invoked when a <button> element is available and clicked on the page
                const myButton = document.querySelector('button');

                myButton.onclick = function () {
                    alert('hello');
                }

                EX 2: assigning an anonymous function to be the value of a variable. this function can be invoked using myGreeting();
                const myGreeting = function () {
                    alert('hello');
                }
            
                But why do this? Just be easy and do function myGreeting() {alert('hello');}

            *** MAINLY USED TO RUN CODE IN RESPONSE TO AN EVENT FIRING, like a button click, USING AN EVENT HANDLER

                EX 3:
                myButton.onclick = function() {
                    // run all the code!
                }

    Function Scope - an important topic
        Why does it matter?
            Security
                external scripts that you call in from elsewhere could change your code b/c they use same variable names and cause conflicts
                can be malicious or accidental

            Organization
                it's like a zoo, keep the right animals together and don't force mingling

            Conflict resolution
                First function/variable/declaration in wins. Others will be ignored.
                Subsequent variable declarations will result in an error.
        
        Global scope - Top level - the zoo keeper with access to all enclosures (code)
            Values defined here are accessible from EVERYWHERE in the code
        
        Local variables - variables defined in the function
        Outer variables - variables defined a step up from a specific function
            *Conflict resolution: If using let (not const) and there is a local and outer conflict, LOCAL wins
        
        Heirarchy and what sees what
            Global declarations, e.g., let x = 12;
                In-function declarations, e.g., function a() {let y = 2;}  

            output(x); //works because x is global
            output(y); //doesn't work because y is within function
                must add output(y); to function, then call with a();

            a function cannot access the information directly in another function -- different scopes
            a function can access anything in the global, so output(x); from within the function works onclick

            if you want to use something out of scope, you must pass value in as a parameter 
    
    Function-ception (functions inside functions)
        Why?
            Useful if you have a big complex function and want to break into sub-functions
        
        Be careful of scope
            Just beacuse you declare a variable in the "master" function, doesn't mean it is defined inside the function definitions (where the code is being run in the sub functions)

            EX: If you want to get a value into sub-functions, you must pass it in.
                function myBiggie() {
                    let myVal = 1;

                    subFun1(myVal);
                    subFun2(myVal);
                    subFun3(myVal);
                }

                function subFun1(value) {
                    console.log(value);
                }
                function subFun2(value) {
                    console.log(value);
                }
                function subFun3(value) {
                    console.log(value);
                }
    
    Function return values
        Some functions return info, some don't.

        Keyword: return
            EX:
            button.onclick = function() {const result = 5 * 5; return result;}
        
        return; // without a value, causes function to exit immediately
            QUESTION: What's the difference in "return" vs "break" then?
            ANSWER: break exits (escapes) the for, while, and switches
                    return exits the entire method being executed (potentially returning a value to the calling function/code)
        
    Function parameters
        Go ahead, pass in some arguments.

            EX: one param
            function functionName(param) {
                alert('This is the parameter: ' + param + '.');
            }
            
            functionName('foo');
        
            EX: multiple params
            function functionName(param1, param2, . . . paramN) {
                // code
            }

            functionName('foo','fooey','fubar')

        Default values
            Like PowerShell.

                EX: default values
                function functionName(param1, param2 = 'defaultString') {
                    alert('Parameter 1 is: ' + param1 + '. Parameter 2 is: ' + param2 + '.')
                }

                functionName('foo'); //results in Parameter 1 is: foo. Parameter 2 is defaultString.

                EX: default values can use another function within
                function functionName(param1, param2 = anotherFunction()) {
                    alert('Parameter 1 is: ' + param1 + '. Parameter 2 is: ' + param2 + '.')
                }

            Default param is evaluated ervery time the function is called without the respective parameter.
                That means: anotherFunction() isn't called at all if text is provided when running the function
                That also means: anotherFunction() could get a different result at different times it is run
            
            Assigning default values post-declaration

                EX:
                function showMessage(text) {
                    // code
                    if (text === undefined) { // if the param is missing
                        text = 'empty message';
                    }

                    alert(text);
                }

                showMessage(); // an empty argument results in "empty message"

                EX: using OR (||)
                function showMessage(text) {
                    // if the text is undefined or falsy, set to 'empty'
                    text = text || 'empty';
                }

    Arrow functions
        Relatively new stuff with simple and concise syntax

        let func = (arg1, arg2, ... argN) => expression
            IS THE SAME AS
        let func = function(arg1, arg2, ... argN) {
            return expression;
        }

        EX: simple concrete example
        let sum = (a, b) => a + b;
            IS THE SAME AS
        let sum = function(1, b) {
            return a + b;
        }
            AND YOU USE IT THE SAME EITHER WAY
        alert (sum(1,2));

        EX: without arguments, keep the parentheses still
        let sayHi = () => alert('hello!');
        sayHi();
    
        EX: dynamic creation of an arrow function
        let age = prompt("Age?", 18);

        let welcome = (age < 18) ? 
            () => alert('Hello') : 
            () => alert('Greetings');

        welcome();

    That ol' JavaScript call stack
        JavaScript is   single threaded
                        non-blocking
                        asynchronous

        The call stack is a:
            Last-In, First-Out (LIFO) data structure
            containing the address at which execution will resume
            and often local variables and parameters from each call.
        
        When one function calls another, that next one goes into the call stack (and the first stays, too)
        As things are returned (or exited), that function gets removed from stack
        
        Stack trace
            Keep in mind, just like when doing any debugging, the most recent calls are at the top.

        Stack overflow
            E.g., function foo() { return foo(); } // returns itself, so calls itself repeatedly, and overflows the buffer / throws the error


Problem Solving in JavaScript
    “The biggest mistake I see new programmers make is focusing on learning syntax instead of learning how to solve problems.” — V. Anton Spraul

    1. Understand - “If you can’t explain something in simple terms, you don’t understand it.” — Richard Feynman
        Draw it
        Reword it
        Know what successful solving looks like
    2. Plan - Reduce the problem to the point where you know how to solve it and write the solution. Then expand the problem slightly and rewrite the solution to match, and keep going until you are back where you started.” — V. Anton Spraul
        This is the design phase.
        UI? Sketch it.
        Inputs needed? Manual or user?
        Desired output?
        Given the inputs, what steps are necessary to return desired output?
            ^^^ This is the "recipe"
        Use pseudo code to help with planning it out
            when user inputs number
                initialize a counter and set it to zero
                while the counter is less than user input number, increment counter by 1
                print value of counter variable
            end program
    3. Split big problems into small problems
        start with the simple problem, moving to the harders, but keep them separate to minimize misses
        “The art of debugging is figuring out what you really told your program to do rather than what you thought you told it to do.”” — Andrew Singer
    (4.) PRACTICE
        Solve a problem daily on coderbyte?
        Paly video games that utilize problem solving skills?
        What other problems can be solved to help overall problem solving?

    Fizz Buzz problem - https://en.wikipedia.org/wiki/Fizz_buzz

        Fizz buzz (often spelled FizzBuzz in this context) has been used as an interview screening device 
        for computer programmers. Writing a program to output the first 100 FizzBuzz numbers is a relatively 
        trivial problem requiring little more than a loop and conditional statements. However, its value in 
        coding interviews is to analyze fundamental coding habits that may be indicative of overall coding 
        ingenuity. [Wikipedia]

        Write a program that takes a user’s input and prints the numbers from one to the number the user 
        entered. However, for multiples of three print Fizz instead of the number and for the multiples of 
        five print Buzz. For numbers which are multiples of both three and five print FizzBuzz. [TOP]

            Take user input
                do print the incremented number starting at 0 until the incremented number equals user input
                    if incremented number is a multiple of 3 && divisible by 5, replace the oyutput with "FizzBuzz"
                    elseif incremented number is a multiple of 3, replace the output with "Fizz" and increment number by 1
                    elseif incremented number is divisible by 5 without a remainder, replace output with "Buzz"
                    else print the number before incrementing it
            
            input: user number

            functions:
                multiple3
                divisible5

            // Take the input
            const userInput = parseInt(prompt("Pick a number.")); // parseInt makes sure we get a Number (no need to force that later, nice)
            
            This didn't really pan out, but keeping anyway. I think the main issues (without much investigation) are:
            - A for-loop would be better here.
            - The functions aren't bad, but might be too complex for the task
            - *** I didn't actually evaluate the results of the function to see if a number or fizz/buzz. could implement the evaluation to make it work. but that is complex.

                    // Starting the incrementing counter
                    let counter = 1;
                    
                    // Functions to do the work
                    function multiple3(counter) {
                        if ((counter % 3) === 0) {
                            return "Fizz";
                        }
                    }

                    function divisible5(counter) {
                        if ((counter % 5) === 0) {
                            return "Buzz";
                        }
                    }

                    function fizzBuzz(counter) {
                        if (divisible5(counter) && multiple3(counter)) {
                            return "FizzBuzz";
                        }
                    }

                    // do-while loop
                    do {
                    if (isNaN(fizzBuzz(counter))) {
                        console.log("FIZZBUZZ" // I kinda stopped at this point. Let's try again.
                    }
                    console.log(counter);
                    alert(fizzBuzz(counter));
                    alert(multiple3(counter));
                    divisible5(counter);
                    counter++;
                    }
                    while (counter <= userInput);
            
            Updated code: javascript_fundies-fizzbuzz.html
                    // Take the input
                    const userInput = parseInt(prompt("Pick a number.")); // parseInt makes sure we get a Number (no need to force that later, nice)
                    
                    // Set up the loop
                    for (let i = 1; i <= userInput; i++) {
                    if ((i % 3 === 0) && (i % 5 === 0)) {
                        console.log("FizzBuzz");
                    } else if (i % 3 === 0) {
                        console.log("Fizz");
                    } else if (i % 5 === 0) {
                        console.log("Buzz");
                    } else {
                        console.log(i);
                    }
                    }

    COMMENTS explain CODE to programmers? No.
        CODE explains COMMENTS to the computer. Break it up and map it out in english first!

        Try writing code with comments first.
            EX:
                // this is the first step
                // this is the second step i decided
                // this is the third step i decided
                . . .
            THEN:
                // this is the first step
                do {x} while (y);
                // this is the second step i decided
                . . .
                // this is the third step i decided
                . . .

    Create your algorithm
        or, a "recipe"

        New variable algorithm (when making a new one): Create a variable called NAME of type TYPE that starts with the value INITVAL.
    
        Input algorithm:
            variable: where answer from user will be STORED. you gotta put out your baseball mit first if you want to catch a ball from someone else.
            message: question being asked of the user
            algorithm: ask the user MESSAGE and store the answer in VARIABLE

    UNDERSTANDING / ALGORITHMS -> IMPLEMENTATION -> DEBUG
    ^ Can't google this one         ^ Can google    ^ Can google

    When debugging, don't start with a solution. 
        Are there things you don't understand? 
        Are you making assumptions that you cannot make?
        Are the right tools being used?


Understanding Errors

    ReferenceError
        thrown when one refers to a variable that is not declared and/or initialized within the current scope

    SyntaxError
        when the code you are trying to run is not written correctly
    
    TypeError
        when:
        - an operand or argument passed to a function is incompatible with the type expected by that operator or function;
        - or when attempting to modify a value that cannot be changed;
        - or when attempting to use a value in an inappropriate way.

        EX: TypeError: str1.push is not a function.
            - We know .push() is a function.
            - It is used to add items to an array.
            - So it is a function of another function, which is a method.
            - And this specific method is not a STRING method, but an ARRAY method.

    Errors tell you what is wrong and where to find it. TOP talks about line #s, etc.

    Reference error will show stack trace, too.

    Good list of some common errors: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_went_wrong

    Errors vs Warnings
        Errors stop execution.
        Warnings give insight to /potential/ problems.
    

Fundamentals Part 4
    ARRAYS vs OBJECTS in JavaScript
        Arrays use numbered indexes
        Objects use named indexes

        When to use?
            Objects IF you want the element names to be STRINGS.
            Arrays when you want the lement names to be NUMBERS.

        Need to check what you're working with?
            typeof doesn't work, becuase arrays are objects, too. just special.

            EX: isArray method
                myArray.isArray(cats); // returns true

            EX: instanceof operator
                myArray instance of Array; // returns true

    Arrays
        create like this: const array_name = [item1, item2, . . .];

        or like this:
            let cars = [];
            cars[0] = "Saab";
            cars[1] = "Volvo";
            . . .

        it IS possible to create undefined "holes" in an array if you set an element
            with a higher index. E.g., arr[0], arr[1], arr[9] can all be set,
            and then 2-8 are "undefined".
        
        and you can use the method .push() to append more items to the array, EX:
            cars.push("Honda");

            POWERSHELL DOES IT WITH +=. THAT IS CONCANTENATION OF STRINGS IN JS.

        DON'T use the keyword new, even though it works. It's unnecessary.
            EX: let cars = new Array("car", "carr", "carrr");
        INSTEAD use the array literal method, that we just saw.
            EX: let cars = ["car", "carr", "carrr"];

        Items accessible by index position
            EX: cars[0] returns car; car[1] returns carr
        
        Array items are overwritable
            EX: cars[0] = "Opel";
        
        Access full array by name
            EX: cars;
            EX: document.getElementById("carlist").innerHTML = cars;
        
        Arrays are Objects
            store different types of variables in the one array object

            Properties and Methods
                .length // returns number of elements
                .sort() // sorts the array
        
            EX: Accessing the first array element (item)
                fruits[0]

            EX: Accessing the last array element
                fruits[fruits.length - 1];
                    // fruits.length = count of array items starting at 1
                    // beacause index starts at 0, must subtract 1 to get LAST item
        
        Array Methods!
            .toString(); // results in: element one,element two,elementy three
                Automatic toString(): JavaScript auto converts an array to a comma separated string when a primitive value is expected (like if inserting an array into an HTML element)
            .join("<separator>"); // just like toString, but you name your separator, e.g., " * ", or ", "

            .pop()
                - removes the last item/element from the array
                - returns the value that was "popped" out / removed
            .push()
                - adds a new item to the end of the array
                - returns the new array.length
            .shift()
                - removes the first item/element from the array
                - returns the value that was "shifted" out
            .unshift()
                - adds a new item to the beginning of the array
                - returns the new array.length
            
            .length - PROPERTY, not a method, evident by no ()'s
                - easy way to append new elements to the array
                EX: cats[cats.length] = "New Cat";
                    // why does this work? because cats.length
                    // starts the count at 1. But indexes start
                    // at 0. So length is always 1 ahead of index.
            
            delete - OPERATOR - prefer POP or SHIFT instead!!
                - easy way to delete an element from a position
                EX: delete cats[0];
                    // this doesn't shift anything, but results in
                    // index 0 being UNDEFINED
                    // PREFER POP OR SHIFT INSTEAD!
            
            .splice()
                - adds a new item to the array, IN A SPECIFIC position
                - syntax: array.splice(<position to ADD>,<elements to REMOVE>, item1, item2, ...);
                    position to add: 0 puts it at the beginning, 1 after the first item, etc.
                    elements to remove: starts removing them at the position specified
                - returns the deleted items (in an array)
                *** can be used to remove elements without leaving holes
                    EX: cats.splice(0, 1); // removes the first element, and returns it
                        // first param says to start before first item
                        // second param says to remove the next thing (the first item in array)
                        // no additional params means nothing added to the array
    
            .concat()
                - merges two arrays, e.g., myGirls and myBoys into myChildren
                - returns the new array
                - can take any number of arguments
                - EX: syntax
                    const myChildren = myGirls.concat(myBoys);
                - EX: more arguments
                    const ourBradyBunch = myGirls.concat(myBoys, yourGirls, yourBoys);
                - EX: takes strings as arguments
                    const ourNewFam = oldFam.concat("Baby Thing");
            .slice()
                - creates a new array from part of an existing array
                - takes two arguments: where to start the slice and how many elements up to (but not including) the end argument
                - returns the new array
                - EX: syntax
                    const myArray = ["one","two","three","four"];

                    let myChoices = myArray.slice(1,3); // should return two and three

            Max or Min - NOPE
                - Yeah, no. JavaScript doesn't have a built in function or method for this.

    Hash Tables? NOPE.
        Named indexes (or, hash tables) are not supported.
        Arrays in JS /always/ use numbered indexes.

        "What if I try using a named index by saying person["first"] = "John"
            instead of person[0] = "John"?"

            Answer: JavaScript redfines your array as an object and you'll get
            bad or unexpected results.

    Loops
        A loop usually has one or more of the following:
            - A counter, initialized with a specific value
            - A condition, to determine whether to run, keep running, or stop
            - An iterator, to increment the counter

        The standard FOR loop
            Syntax:
                for (initializer; condition; final-expression) {
                    // code to run
                }
            Initializer: usually a variable set to a number, which is incremented to count the number of times the loop has run. sometimes referred to as a "counter variable"
            Condition: defines when the loop should stop looping
            Final-expression: this is always evaluated (run) each time the loop has gone through a full iteration. usually it serves to increment the counter.

            You can skip any part of the for loop if you want, e.g., for (;condition;){//code}

        break; // bounces ya out of that loop completely
        continue; // like break, but it breaks out and skips to the NEXT ITERATION of the same loop
        
        While, and do ... while
            Syntax: while loop
                initializer
                while (condition) {
                    // code to run

                    final-expression
                }
            
            Syntax: do ... while loop
                initializer
                do {
                    // code to run

                    final-expression
                } while (condition)
            
            *** What is the difference?
                * The while loop evaluates the condition before running the code!
                    UPSHOT: the thing MIGHT NOT be done at least once.
                * The do...while loop evaluates the condition after running the code!
                    UPSHOT: the thing WILL be done at least once.
            
            *** The for loop vs the while loop -- which one?
                * The for loop is better suited for when you have a static number to count to
                * The while loop is handy when you don't know how many iterations it will take to make it truthy

        Looping Array Elements
            EX: for loop
                const cats = ["Monty", "Arla"];
                let catsLength = cats.length;

                let text;

                text = "<ul>";

                    for (let i = 0; i < catsLength; i++) {
                        text += "<li>" + cats[i] + "</li>";
                    }
                
                text += "</ul>";
            
            EX: .forEach() method
                const cats = ["Monty", "Arla"];

                let text = "<ul>";
                cats.forEach(myFunction);
                text += "</ul>";

                function myFunction(value) {
                    text += "<li>" + value + "</li>";
                }
        
        EX: output even numbers in a loop
            for (let i = 1; i < 11; i++) {
                if (!(i % 2)) {
                    alert(i);
                }
            }

    Test Driven Development (TDD)
        Writing test scripts for your code before you write the code
        Goal is to make sure you know immediately when your code works, not guessing and checking
        (More learning on this later)

DOM Manipulation
    Document Object Model

    When working with DOM, use selectors to choose nodes you work with.
    - CSS-style selectors
        EX: div.main
        EX: .main
        EX: #id > .main
        EX: div#id > div.main
    - Relational selectors
        EX: firstElementChild
        EX: lastElementChild
        EX: previousElementSibling
    
    DOM Methods
        To select, use query selectors
            element.querySelector(selector) returns reference to the first match of selector
            element.querySelectorAll(selectors) returns a "nodelist" containing references to all of the matches of the selectors
                - NOTE: not an array. is a nodelist. can convert to array if you want (Array.from() or the spread operator)
            
        To create a new element (just in memory, not yet inserted in DOM)
            Function example: const div = document.createElement('div');
        
        Manipulating elements
            IMPORTANT! JavaScript runs when the script tag is encountered. DOM
            manipulation works best when JS runs after nodes are created in
            DOM. Options: Make sure <script> is at the end of your HTML. If
            using <script> in the <head>, add "defer" keyword (<script src='js-file.js' defer></script>)

            Append
                parentNode.appendChild(childNode()
                parentNode.insertBefore(newNode, referenceNode)
            
            Remove
                parentNode.removeChild(child)
            
            Alter
                Can do things like change attributes, classes, inline style, etc

                const div = document.createElement('div');
                EX: div.style.color = 'blue';
                EX: div.style['background-color']; // brackets are used for kebab-cased CSS rules! ***
                EX: div.style.cssText = 'color: blue; background: white';
                EX: div.setAttribute('style', 'color: blue; background white');

            Editing attributes
                div.setAttribute('id', 'theDiv');
                    // if id exists, update it to "theDiv", else create an id with value "theDiv"
                
                div.getAttribute('id');

                div.removeAttribute('id');
            
            Working with classes
                div.classList.add('new');
                    //adds class "new" to your div
                
                div.classList.remove('new');

                div.classList.toggle('active');
                    //if it has the class, remove it; if it doesn't, add it.
                    // often it is cleaner to toggle than to add and remove styles! ***

            Adding text content
                div.textContent = 'Hello World!';
                    // creates a text node containing "Hello world!" and inserts it in the div
                
            Adding HTML content
                div.innerHTML = '<span>Hello World!</span>'

                .innerText is another good option instead of .textContent possibly
            
                NOTE: textContent is preferred. innerHTML can create security risks if misused.
                    https://www.youtube.com/watch?v=ns1LX6mEvyM&ab_channel=WebDevSimplified
                    Example is someone using <img src onerror="alert('hi')">
                    Because when am img src is blank, it can do the "on error" bit
                    If you're using innerHTML in your site, you COULD be vulnerable to that type of injection
                    Why not just a <script> tag? they don't run on their own.

                    If you MUST use innerHTML, you must strip the HTML elements out so it can't render.
    
    Events!
        Three ways to do them:
            1. Attach functions attributes directly on HTML elements
            2. Set the "on_event_" property on the DOM object in your JS
            3. (Preferred) Attach event listeners to the nodes in your JS
        
            1. <button onclick="alert('Hi')">Click me!</button>
            2. HTML: set an ID on btn
                JS: querySelect('#id'), then btn.onclick = () => alert('Hi');
            3. HTML: set an ID on btn
                JS: querySelect('#id'), then addEventListener('click', () => {alert('HI');})
            Examples: ./javascript_fundies-events.js
        
            All three ways accept named functions as well.
                1. button onclick="alertFunction()"
                2. btn.onclick = alertFunction;
                3. btn.addEventListener('click', alertFunction);
        
        Callbacks
            btn.addEventListener('click', function (e) {
                console.log(e);
            })

            "e" is a call back. It references the event itself.

            Callbacks are functions passed into another function as an argument.

            EX: let cats = ["monty", "arla"];
                cats.forEach((cat) => {console.log(cat);})
        
        Efficient Attachment
            Can attach event listeners to many elements by iterating through the list

            EX: const buttons = document.querySelectorAll('button'); // buttons is a node list
                buttons.forEach( (button) => { // forEach method iterates through each button
                    button.addEventListener('click', () => {
                        alert(button.id); // and for each one of them, add the click listener
                    })
                })
        
        Some common useful events:
            - click
            - dblclick
            - keypress
            - keydown
            - keyup
            https://www.w3schools.com/jsref/dom_obj_event.asp

